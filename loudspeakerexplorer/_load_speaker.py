import re

import engarde.decorators as ed
import pandas as pd


def _fix_unnamed_columns(columns):
    # pd.read_table() expects the following multi-level column headers:
    #   A, A, A, A, B, B, B, B
    #   I, I, J, J, K, K, L, L
    #   X, Y, X, Y, X, Y, X, Y
    # But the data we have uses the following header format instead:
    #   A, B
    #   I, J, K, L
    #   X, Y, X, Y, X, Y, X, Y
    # When confronted with this header, pd.read_table() gets confused and
    # generates the following multi-level column index:
    #   A, _, _, _, B, _, _, _
    #   I, _, J, _, K, _, L, _
    #   X, Y, X, Y, X, Y, X, Y
    # Where "_" is some autogenerated column name in the form:
    # "Unnamed: 1_level_0"
    # This function restores the correct column names by replacing every
    # "Unnamed" column with the name of the last known column on that level.
    last_names = [None] * columns.nlevels

    def fix_column(column):
        for level, label in enumerate(column):
            if not label.startswith('Unnamed: '):
                last_names[level] = label
        return tuple(last_names)
    return pd.MultiIndex.from_tuples(fix_column(column) for column in columns.values)


def _index_by_frequency(data):
    # Expects input in the following form:
    #   (Additional top column levels)
    #   FR1                     FR2
    #   "Frequency [Hz]" value  "Frequency [Hz]" value
    #   42.42            1.234  42.42            2.345
    #   43.43            3.456  43.43            5.678
    # And reindexes it by the "Frequency [Hz]" column, producing:
    #          value
    #          (Additional top column labels)
    #          FR1    FR2
    #   42.42  1.234  2.345
    #   43.43  3.456  5.678
    preserve_column_level = list(range(data.columns.nlevels - 1))
    return (data
            # Move all columns levels except the bottommost one into the index
            .stack(level=preserve_column_level)
            # Drop the topmost (default) index level as it's not useful anymore
            .reset_index(level=0, drop=True)
            # Use the frequency as the new bottommost index level
            .set_index('Frequency [Hz]', append=True)
            # Move all other index levels back to columns
            .unstack(level=preserve_column_level))


def _cleanup_spl_column(column):
    # In "Sound Pessure Level [dB] / [2.83V 1m]", eliminates " / [2.83V 1m]", as
    # it varies between measurements
    match = re.match(r'^(Sound Pessure Level \[dB\])', column)
    return column if match is None else match.group(1)


def _load_fr(file):
    fr = pd.read_table(file, header=[0, 1, 2], thousands=',')
    fr.columns = _fix_unnamed_columns(fr.columns)
    return (fr
            .rename(columns=_cleanup_spl_column)
            .pipe(_index_by_frequency))


@ed.none_missing()
def load_speaker(dir):
    # If the none_missing() assertion fires, it likely means something is wrong or
    # corrupted in the data files of the speaker (e.g. some frequencies present in
    # some columns/files but not others)
    return pd.concat(
        (_load_fr(file) for file in filter(lambda path: not path.name in (
            'LICENSE.txt', 'Read License Agreement.txt', 'speaker_metadata.yaml'), dir.iterdir())),
        axis='columns')
