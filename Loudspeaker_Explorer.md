---
jupyter:
  colab:
    collapsed_sections:
    - preliminary-boilerplate
    - load
    - raw-summary
    - sensitivity
    - normalization
    - smoothing
    - plot-settings
    - data-check
    - off-axis-responses
    - horizontal-reflection-responses
    - vertical-reflection-responses
    name: Loudspeaker Explorer
    toc_visible: true
  jupytext:
    notebook_metadata_filter: colab,-jupytext.text_representation.jupytext_version
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.2'
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

<!-- #region id="view-in-github" -->
<!-- The "view-in-github" magic section ID is handled specially by Colab, which will not show its contents. Note that this only seems to work if this is the first section. -->
**You are viewing the source version of the Loudspeaker Explorer notebook.** You can also open the ready-to-use, published version in [Colab]((https://colab.research.google.com/github/dechamps/LoudspeakerExplorer-rendered/blob/master/Loudspeaker_Explorer.ipynb)).

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/dechamps/LoudspeakerExplorer-rendered/blob/master/Loudspeaker_Explorer.ipynb)
<!-- #endregion -->

<!-- #region tags=["buildinfo"] -->

# The Loudspeaker Explorer

_By [Etienne Dechamps](https://www.audiosciencereview.com/forum/index.php?members/edechamps.4453/) (etienne@edechamps.fr)_ - [ASR thread](https://www.audiosciencereview.com/forum/index.php?threads/loudspeaker-explorer-analyze-visualize-compare-speaker-data.11503/) - [GitHub](https://github.com/dechamps/LoudspeakerExplorer)<!--BUILDINFO-->

**All data provided by [amirm](https://www.audiosciencereview.com/forum/index.php?members/amirm.2/) from [AudioScienceReview](https://www.audiosciencereview.com/). Consider [making a donation](https://www.audiosciencereview.com/forum/index.php?threads/how-to-support-audio-science-review.8150/) if you enjoy the use of this data.**

Welcome to the [Loudspeaker Explorer](https://colab.research.google.com/github/dechamps/LoudspeakerExplorer-rendered/blob/master/Loudspeaker_Explorer.ipynb), a speaker measurement visualization, analysis and comparison tool. This is an interactive [Colaboratory Notebook](https://colab.research.google.com/).

## How to use this notebook

To run the code and (re)generate the data, go to the **Runtime** menu and click **Run all** (CTRL+F9). **You will need to repeat this every time you change any of the settings or code** (e.g. if you enable or disable speakers).

**All the charts are interactive.** Use the mousewheel to zoom, and drag & drop to pan. Click on a legend entry to highlight a single response; hold shift to highlight multiple responses. Double-click to reset the view. (PROTIP: to quickly switch back and forth between speakers, select the speaker dropdown, then use the left-right arrow keys on your keyboard.)

**Charts can take a few seconds to load when scrolling**, especially if you're using the notebook for the first time. Be patient.

**Charts will not be generated if the section they're under is folded while the notebook is running.** To manually load a chart after running the notebook, click on the square to the left of the *Show Code* button. Or simply use *Run all* again after unfolding the section.

## Acknowledgments

None of this would have been possible without [amirm](https://www.audiosciencereview.com/forum/index.php?members/amirm.2/)'s [tremendous work](https://www.audiosciencereview.com/forum/index.php?threads/announcement-asr-will-be-measuring-speakers.10725/) in measuring speakers. All the data used by this tool is from measurements made by amirm for [AudioScienceReview](https://www.audiosciencereview.com/). If you like what you see, [consider making a donation](https://www.audiosciencereview.com/forum/index.php?threads/how-to-support-audio-science-review.8150/).

This notebook is powered by amazing software: [Google Colaboratory](https://colab.research.google.com/), [Jupyter](https://jupyter.org/), [Jupytext](https://github.com/mwouts/jupytext), [Pandas](https://pandas.pydata.org/), and [Altair](https://altair-viz.github.io/).

## License

The *code* and accompanying text of Loudspeaker Explorer is published under [MIT License](https://github.com/dechamps/LoudspeakerExplorer/blob/master/LICENSE.txt).

The *measurement data* is not part of Loudspeaker Explorer - it is published by Audio Science Review LLC under the [Creative Commons BY-NC-SA 4.0 license](https://creativecommons.org/licenses/by-nc-sa/4.0/). Because this is a "share alike" license, **all data generated by Loudspeaker Explorer, including the charts, is de facto licensed under these terms as well**. Note that these license terms do not apply to measurements published before 2020-03-02, as these do not come with a clear license.

## Other tools

You might also be interested in:

 - [pozz](https://www.audiosciencereview.com/forum/index.php?members/pozz.7752/)'s [ASR Speaker Review and Measurement Index](https://www.audiosciencereview.com/forum/index.php?pages/SpeakerTestData/)
 - [MZKM](https://www.audiosciencereview.com/forum/index.php?members/mzkm.4645/)'s [Preference Rating data](https://docs.google.com/spreadsheets/d/e/2PACX-1vRVN63daR6Ph8lxhCDUEHxWq_gwV0wEjL2Q1KRDA0J4i_eE1JS-JQYSZy7kCQZMKtRnjTOn578fYZPJ/pubhtml)
 - [pierre](https://www.audiosciencereview.com/forum/index.php?members/pierre.344/)'s [Spinorama visualizations](https://pierreaubert.github.io/spinorama/)
<!-- #endregion -->
<!-- #region id="preliminary-boilerplate" -->
# Preliminary boilerplate
<!-- #endregion -->

```python
# https://jakevdp.github.io/blog/2017/12/05/installing-python-packages-from-jupyter/
import sys
!{sys.executable} -m pip install --progress-bar=off numpy pandas engarde ipywidgets yattag altair

from os import environ
from pathlib import Path
import re
import numpy as np
import pandas as pd
import engarde.decorators as ed
import IPython
import ipywidgets as widgets
import yattag
import altair as alt
import json
```

```python
def setting(path, widget, on_new_value=lambda x: None):
    path = (Path('settings') / path)
    path = path.with_name(path.name + '.json')
    try:
        with path.open(mode='r') as file:
            widget.value = json.load(file)
    except FileNotFoundError:
        pass
    def on_change(change):
        try:
            path.parent.mkdir(parents=True)
        except FileExistsError:
            pass
        new_path = path.with_name(path.name + '.new')
        with new_path.open(mode='w') as file:
            json.dump(change['new'], file)
        new_path.rename(path)
        return on_new_value(change['new'])
    on_new_value(widget.value)
    widget.observe(on_change, names='value')
    return widget

def recurse_attr(obj, attr, fn):
    for child in getattr(obj, attr, []):
        recurse_attr(child, attr, fn)
    fn(obj)

prerender_mode = bool(environ.get('LOUDSPEAKER_EXPLORER_PRERENDER', default=False))

def display_widget(widget, value):
    widget.layout.display = None if value else 'none'
    
def lookup_widget_option_label(widget):
    return {value: label for label, value in widget.options}[widget.value]

def form(widget):
    form_banner = widgets.HTML()
    def set_form_banner(contents):
        form_banner.value = '<div style="text-align: left; padding-left: 1ex; border: 2px solid red; background-color: #eee">' + contents + '</div>'
    if prerender_mode:
        set_form_banner('<strong>Settings disabled</strong> because the notebook is not running. Run the notebook (in Colab, "Runtime" → "Run All") to change settings.')
        def disable_widget(widget):
            widget.disabled = True
        recurse_attr(widget, 'children', disable_widget)
    recurse_attr(widget, 'children',
        lambda widget: widget.observe(
            lambda change: set_form_banner('<strong>Settings have changed.</strong> Run the notebook again (in Colab, "Runtime" → "Run All") for the changes to take effect.'), names='value'))
    return widgets.VBox([form_banner, widget])
```

# Speaker selection

This is the most important setting. Here you can select the speakers you wish to analyze and compare. See below for more information on each speaker. **You will have to run the notebook by clicking "Runtime" → "Run all" before you can change the selection.**

Note that the following speakers, despite having been measured by amirm, are not (yet) available in this tool:

 - [**Genelec 8341A (before treble ripple issue fix)**](https://www.audiosciencereview.com/forum/index.php?threads/genelec-8341a-sam%E2%84%A2-studio-monitor-review.11652/page-2#post-335133): the raw data was [not published](https://www.audiosciencereview.com/forum/index.php?threads/genelec-8341a-sam%E2%84%A2-studio-monitor-review.11652/page-5#post-335291). The data shown here is from the [fixed](https://www.audiosciencereview.com/forum/index.php?threads/genelec-8341a-sam%E2%84%A2-studio-monitor-review.11652/#post-335109) [measurement](https://www.audiosciencereview.com/forum/index.php?threads/genelec-8341a-sam%E2%84%A2-studio-monitor-review.11652/).
 - [**Kali IN-8 (damaged sample)**](https://www.audiosciencereview.com/forum/index.php?threads/kali-audio-in-8-studio-monitor-review.10897/): the raw data was not published. The data shown here is for the [good sample](https://www.audiosciencereview.com/forum/index.php?threads/kali-audio-in-8-studio-monitor-review.10897/page-29#post-318617).
 - [**Neumann KH80 (sample 2, low order)**](https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-speaker-measurements-take-two.11323/): the raw data was not published. The data shown here is from the [high order measurement](https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-speaker-measurements-take-two.11323/page-12#post-324456).
 - [**NHT Pro M-00**](https://www.audiosciencereview.com/forum/index.php?threads/nht-pro-m-00-powered-monitor-review.10859/): the raw data was not published.
 - [**Yamaha HS5**](https://www.audiosciencereview.com/forum/index.php?threads/yamaha-hs5-powered-monitor-review.10967/): the raw data published is incomplete and does not come in the standard zipfile format that the tool expects.

Also note that the datasets for **JBL 305P MkII** and **Neumann KH80 (sample 1)** are missing *Directivity Index* data. Due to a bug in the tool this also breaks the Spinorama charts unless another speaker is also selected.

Also note that a [measurement artefact](https://www.audiosciencereview.com/forum/index.php?threads/klipsch-r-41m-bookshelf-speaker-review.11566/page-3#post-332136) in the form of a slight [ripple in high frequencies](https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-speaker-measurements-take-two.11323/page-10#post-324189) (above 4 kHz or so) is present in all measurements made before 2020-02-23. This was [fixed](https://www.audiosciencereview.com/forum/index.php?threads/genelec-8341a-sam%E2%84%A2-studio-monitor-review.11652/#post-335109) starting from the Genelec 8341A measurement.

Also note that the **Revel F35** measurement suffers from [numerical computation issues](https://www.audiosciencereview.com/forum/index.php?threads/revel-f35-speaker-review.12053/page-20#post-354889) that cause erroneous spikes around 1 kHz.

**How to add a new speaker**: in the following code block, add a new variable, and repeat the pattern in the `speakers` variable assignment. That's it - everything else should take care of itself. Note that the tool expects a zipfile in the format that amirm publishes (which presumably is the Klippel analysis software export format). If you want to upload the zipfile manually instead of using `Data URL`, you can do that using the Colab file browser on the left - just make sure the name of the file matches the `Speaker` field in the raw specification so that the tool can find it.

```python
speakers = pd.DataFrame([{
    'Speaker': 'Adam Audio S2V',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/adam-s2v-spinorama-cea2034-zip.50119/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/adam-s2v-studio-monitor-review.11455/',
    'Product URL': 'https://www.adam-audio.com/en/s-series/s2v/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/adam-s2v-monitor-powered-studio-speaker-audio-review-jpg.50100/',
    'Measurement Date': pd.Timestamp('2020-02-14'),
    'Active': True,
    'Price (Single, USD)': 875.00,
  }, {
    'Speaker': 'Ascend Acoustics CBM-170 SE',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/ascend-cbm170-spinorama-data-zip.52802/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/ascend-cbm-170-se-speaker-review.11839/',
    'Product URL': 'http://www.ascendacoustics.com/pages/products/speakers/cbm170/cbm170.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/ascend-acoustics-cbm-170-bookshelf-speaker-audio-review-jpg.52606/',
    'Measurement Date': pd.Timestamp('2020-03-02'),
    'Active': False,
    'Price (Single, USD)': 150.00,
  }, {
    'Speaker': 'Ascend Acoustics CMT-340 SE Center',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/ascend-acoustics-cmt-340-spin-data-zip.52403/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/ascend-cmt-340-se-center-channel-speaker-review.11797/',
    'Product URL': 'http://www.ascendacoustics.com/pages/products/speakers/cmt340c/cmt340c.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/ascend-acoustics-cmt-340-se-center-home-theater-speaker-baloon-audio-review-jpg.52239/',
    'Measurement Date': pd.Timestamp('2020-02-29'),
    'Active': False,
    'Price (Single, USD)': 150.00,
  }, {
    'Speaker': 'Ascend Acoustics Sierra-2',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/ascend-sierra-2-spin-data-zip.52401/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/ascend-sierra-2-speaker-review.11813/',
    'Product URL': 'http://www.ascendacoustics.com/pages/products/speakers/SRM2/srm2.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/ascend-acoustics-sierra-2-bookshelf-stand-mount-speaker-audio-review-jpg.52386/',
    'Measurement Date': pd.Timestamp('2020-03-01'),
    'Active': False,
    'Price (Single, USD)': 740.00,
  }, {
    'Speaker': 'Dayton Audio B652-AIR',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/dayton-audio-b652-air-spinorama-zip.49763/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/dayton-audio-b652-air-speaker-review.11410/',
    'Product URL': 'https://www.daytonaudio.com/product/1243/b652-air-6-1-2-2-way-bookshelf-speaker-with-amt-tweeter-pair',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/dayton-audio-b652-air-bookshelf-cheap-speakers-audio-review-jpg.49739/',
    'Measurement Date': pd.Timestamp('2020-02-11'),
    'Active': False,
    'Price (Single, USD)': 39.00,
  }, {
    'Speaker': 'Elac Adante AS-61',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/elac-adante-as-61-cea-2034-spin-data-zip.50439/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/elac-adante-as-61-speaker-review.11507/',
    'Product URL': 'https://www.elac.com/series/adante/as-61/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/elac-adante-as-61-bookshelf-speaker-audio-review-jpg.50415/',
    'Measurement Date': pd.Timestamp('2020-02-16'),
    'Active': False,
    'Price (Single, USD)': 1250.00,
  }, {
    'Speaker': 'Elac Debut Reference DBR-62',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/elac-dbr62-zip.55724/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/elac-debut-reference-dbr-62-speaker-review.12232/',
    'Product URL': 'https://www.elac.com/series/debut-reference/dbr-62/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/elac-debut-reference-dbr-62-bookshelf-speaker-review-jpg.55712/',
    'Measurement Date': pd.Timestamp('2020-03-25'),
    'Active': False,
    'Price (Single, USD)': 300.00,
  }, {
    'Speaker': 'Emotiva Airmotiv 6s',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/emotiva-airmotive-6s-spinorama-zip.48091/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/emotiva-airmotiv-6s-powered-speaker-review.11185/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/emotiva-airmotive-6s-powered-monitor-speaker-review-jpg.48017/',
    'Measurement Date': pd.Timestamp('2020-01-31'),
    'Active': True,
    'Price (Single, USD)': 250.00,
  }, {
    'Speaker': 'Genelec 8341A',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/genelec-8431a-spl-adjusted-zip.51413/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/genelec-8341a-sam%E2%84%A2-studio-monitor-review.11652/',
    'Product URL': 'https://www.genelec.com/8341a',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/genelec-8341a-sam%E2%84%A2-studio-monitor-powered-speaker-audio-review-jpg.51396/',
    'Measurement Date': pd.Timestamp('2020-02-23'),
    'Active': True,
    'Price (Single, USD)': 2950.00,
  }, {
    'Speaker': 'Harbeth Monitor 30 (low order)',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/harbeth-monitor-ces2034-spinorama-zip.47527/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/harbeth-monitor-30-speaker-review.11108/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/harbeth-monitor-30-speaker-review-jpg.47512/',
    'Measurement Date': pd.Timestamp('2020-01-26'),
    'Active': False,
    'Price (Single, USD)': 1600.00,
  }, {
    'Speaker': 'Harbeth Monitor 30 (high order)',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/harbeth-30-high-order-spin-data-zip.49385/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-speaker-measurements-take-two.11323/page-10#post-324345',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/harbeth-monitor-30-speaker-review-jpg.47512/',
    'Measurement Date': pd.Timestamp('2020-02-09'),
    'Active': False,
    'Price (Single, USD)': 1600.00,
  }, {
    'Speaker': 'Infinity R162',
    'Enabled': True,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/inifinity-r162-spinorama-zip.56832/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/infinity-r162-bookshelf-speaker-review.12333/',
    'Product URL': 'https://www.harmanaudio.com/loudspeakers/REFERENCE+162.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/inifinity-r162-bookshelf-home-theater-speaker-review-jpg.56774/',
    'Measurement Date': pd.Timestamp('2020-04-01'),
    'Active': False,
    'Price (Single, USD)': 135.00,
  }, {
    'Speaker': 'JBL 305P MkII',
    'Enabled': False,
    # https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-monitor-review.11018/page-2#post-310325
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-305p-mark-ii-cea2034-zip.46835/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/jbl-305p-mkii-and-control-1-pro-monitors-review.10811/',
    'Product URL': 'https://www.jbl.com/studio-monitors/305PMKII.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-305p-mkii-speaker-powered-monitor-review-jpg.45226/',
    'Measurement Date': pd.Timestamp('2020-01-10'),
    'Active': True,
    'Price (Single, USD)': 150.00,
  }, {
    'Speaker': 'JBL 705P (sample 1)',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-705p-spinorama-zip.53447/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/jbl-705p-studio-monitor-review.11944/',
    'Product URL': 'https://jblpro.com/products/705p',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-705p-studio-powered-monitor-distortion-and-spl-speaker-review-jpg.53429/',
    'Measurement Date': pd.Timestamp('2020-03-09'),
    'Active': True,
    'Price (Single, USD)': 1000.00,
  }, {
    'Speaker': 'JBL 705P (sample 2)',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-705p-sample-2-zip.53543/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/jbl-705p-studio-monitor-review.11944/page-8#post-346907',
    'Product URL': 'https://jblpro.com/products/705p',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-705p-studio-powered-monitor-distortion-and-spl-speaker-review-jpg.53429/',
    'Measurement Date': pd.Timestamp('2020-03-10'),
    'Active': True,
    'Price (Single, USD)': 1000.00,
  }, {
    'Speaker': 'JBL Control 1 Pro',
    'Enabled': False,
    # https://www.audiosciencereview.com/forum/index.php?threads/jbl-305p-mkii-and-control-1-pro-monitors-review.10811/page-24#post-315827
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-control-1-pro-zip.47821/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/jbl-305p-mkii-and-control-1-pro-monitors-review.10811/',
    'Product URL': 'https://jblpro.com/en/products/control-1-pro',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-control-1-pro-monitor-review-jpg.45228/',
    'Measurement Date': pd.Timestamp('2020-01-10'),
    'Active': True,
    'Price (Single, USD)': 82.00,
  }, {
    'Speaker': 'JBL One Series 104',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-104-spinorama-zip.47297/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/jbl-one-series-104-powered-monitor-review.11076/',
    'Product URL': 'https://jblpro.com/en-US/products/104',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-one-series-104-powered-monitor-speaker-review-jpg.47273/',
    'Measurement Date': pd.Timestamp('2020-01-25'),
    'Active': True,
    'Price (Single, USD)': 65.00,
  }, {
    'Speaker': 'JBL Studio 530',
    'Enabled': True,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-studio-530-spinorama-zip.56405/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/jbl-studio-530-speaker-measurements.12298/',
    'Product URL': 'https://www.jbl.com/loudspeakers/STUDIO+530.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/jbl-studio-530-speaker-monitor-audio-review-jpg.56394/',
    'Measurement Date': pd.Timestamp('2020-03-31'),
    'Active': False,
    'Price (Single, USD)': 300.00,
  }, {
    'Speaker': 'Kali Audio IN-8',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kali-in-8-spinorama-zip.48347/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/kali-audio-in-8-studio-monitor-review.10897/page-29#post-318617',
    'Product URL': 'https://www.kaliaudio.com/independence',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kali-audio-in-8-studio-monitor-powered-speaker-review-jpg.45827/',
    'Measurement Date': pd.Timestamp('2020-02-02'),
    'Active': True,
    'Price (Single, USD)': 400.00,
  }, {
    'Speaker': 'KEF LS50',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kef-ls50-ces2034-zip.47785/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/kef-ls50-bookshelf-speaker-review.11144/',
    'Product URL': 'https://us.kef.com/catalog/product/view/id/1143/s/ls50-mini-monitor-speaker-pair/category/94/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kef-ls50-bookshelf-speaker-review-jpg.47768/',
    'Measurement Date': pd.Timestamp('2020-01-28'),
    'Active': False,
    'Price (Single, USD)': 750.00,
  }, {
    'Speaker': 'KEF Q100',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kef-q100-spinorama-zip.53776/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/kef-q100-speaker-review.11987/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kef-q100-bookshelf-speaker-coaxial-driver-audio-review-jpg.53759/',
    'Measurement Date': pd.Timestamp('2020-03-11'),
    'Active': False,
    'Price (Single, USD)': 225.00,
  }, {
    'Speaker': 'KEF R3',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kef-r3-spinorama-zip.54005/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/kef-r3-speaker-review.12021/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/kef-r3-three-way-stand-mount-speaker-audio-review-jpg.53994/',
    'Measurement Date': pd.Timestamp('2020-03-12'),
    'Active': False,
    'Price (Single, USD)': 1000.00,
  }, {
    'Speaker': 'Klipsch R-41M',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/klipsch-r41m-spin-data-zip.50860/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/klipsch-r-41m-bookshelf-speaker-review.11566/',
    'Product URL': 'https://www.klipsch.com/products/r-41m-bookshelf-speaker-blk-gnm',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/klipsch-r-41m-booksehlf-speaker-audio-review-jpg.50841/',
    'Measurement Date': pd.Timestamp('2020-02-19'),
    'Active': False,
    'Price (Single, USD)': 75.00,
  }, {
    'Speaker': 'Klipsch RP-600M',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/klipsch-rp-600m-spinorama-zip.55056/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/klipsch-rp-600m-speaker-review.12138/',
    'Product URL': 'https://www.klipsch.com/products/rp-600m-bookshelf-speaker',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/klipsch-rp-600m-bookshelf-speaker-audio-review-jpg.55039/',
    'Measurement Date': pd.Timestamp('2020-03-19'),
    'Active': False,
    'Price (Single, USD)': 315.00,
  }, {
    'Speaker': 'Micca RB42',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/micca-rb42-cea2034-spinorama-zip.48638/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/micca-rb42-bookshelf-speaker-review.11267/',
    'Product URL': 'https://www.miccatron.com/micca-rb42-reference-bookshelf-speakers/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/micca-rb42-bookshelf-budget-speaker-review-jpg.48623/',
    'Measurement Date': pd.Timestamp('2020-02-04'),
    'Active': False,
    'Price (Single, USD)': 75.00,
  }, {
    'Speaker': 'Neumann KH 80 DSP (sample 1)',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/neumann-kh-80-cea2034-zip.46824/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-monitor-review.11018/',
    'Product URL': 'https://www.neumann.com/homestudio/en/kh-80',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/neumann-kh-80-dsp-monitor-active-studio-pro-speaker-audio-review-jpg.46803/',
    'Measurement Date': pd.Timestamp('2020-01-21'),
    'Active': True,
    'Price (Single, USD)': 500.00,
  }, {
    'Speaker': 'Neumann KH 80 DSP (sample 2)',
    'Enabled': False,
    # https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-speaker-measurements-take-two.11323/page-12#post-324456
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/neumann-kh80-dsp-1000-point-order-20-spin-datra-zip.49443/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/neumann-kh-80-dsp-speaker-measurements-take-two.11323/',
    'Product URL': 'https://www.neumann.com/homestudio/en/kh-80',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/neumann-kh-80-dsp-monitor-active-studio-pro-speaker-audio-review-jpg.46803/',
    'Measurement Date': pd.Timestamp('2020-02-08'),
    'Active': True,
    'Price (Single, USD)': 500.00,
  }, {
    'Speaker': 'Pioneer SP-BS22-LR',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/pioneer-sp-bs22-lr-spinorama-2-zip.49024/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/pioneer-sp-bs22-lr-bookshelf-speaker-review.11303/',
    'Product URL': 'https://intl.pioneer-audiovisual.com/products/speakers/sp-bs22-lr/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/pioneer-sp-bs22-lr-budget-bookshelf-speaker-review-jpg.48945/',
    'Measurement Date': pd.Timestamp('2020-02-07'),
    'Active': False,
    'Price (Single, USD)': 80.00,
  }, {
    'Speaker': 'Pioneer Elite SP-EBS73-LR',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/pioneer-elite-sp-eb73lr-spinorama-zip.55313/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/pioneer-elite-sp-ebs73-lr-atmos-speaker-review.12163/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/pioneer-elite-sp-eb73lr-atmos-bookshelf-speaker-audio-review-jpg.55312/',
    'Measurement Date': pd.Timestamp('2020-03-21'),
    'Active': False,
    'Price (Single, USD)': 375.00,
  }, {
    'Speaker': 'Pioneer Elite SP-EC73',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/pioneer-sp-ec73-speaker-spinorama-zip.55573/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/pioneer-elite-sp-ec73-center-speaker-review.12197/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/pioneer-sp-ec73-elite-center-speaker-audio-review-jpg.55550/',
    'Measurement Date': pd.Timestamp('2020-03-23'),
    'Active': False,
    'Price (Single, USD)': 400.00,
  }, {
    'Speaker': 'Polk T15',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/polk-t15-spin-data-zip.52404/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/polk-t15-bookshelf-speaker-review.11720/',
    'Product URL': 'https://en.polkaudio.com/shop/polkaudio-tseries/t15',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/polk-t15-bookshelf-budget-speakers-audio-review-jpg.51865/',
    'Measurement Date': pd.Timestamp('2020-02-27'),
    'Active': False,
    'Price (Single, USD)': 40.00,
  }, {
    'Speaker': 'Realistic MC-1000',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/realistic-mc-1000-spinorama-zip.48797/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/mc-1000-best-speaker-in-the-world.11283/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/realistic-mc-1000-radio-shack-2-way-vintage-speaker-listing-jpg.48786/',
    'Measurement Date': pd.Timestamp('2020-02-06'),
    'Active': False,
    'Price (Single, USD)': 120.00,  # $30 in 1978, adjusted for inflation
  }, {
    'Speaker': 'Revel C52',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-c52-spinorama-zip.52515/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/revel-c52-speaker-review-and-measurements.10934/',
    'Product URL': 'https://www.revelspeakers.com/support/legacy/lsupport-center-channel/C52-.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-c52-center-speaker-3-way-review-jpg.46189/',
    'Measurement Date': pd.Timestamp('2020-01-17'),
    'Active': False,
    'Price (Single, USD)': 2500.00,
  }, {
    'Speaker': 'Revel F35',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-f35-spinorama-zip.54290/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/revel-f35-speaker-review.12053/',
    'Product URL': 'https://www.revelspeakers.com/products/types/floorstanding/F35-.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-f35-speaker-audio-review-jpg.54271/',
    'Measurement Date': pd.Timestamp('2020-03-15'),
    'Active': False,
    'Price (Single, USD)': 800.00,
  }, {
    'Speaker': 'Revel M16',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-m16-spin-zip.52914/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/revel-m16-speaker-review.11884/',
    'Product URL': 'https://www.revelspeakers.com/products/types/bookshelf/M16-.html',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-m16-standmount-bookshelf-high-end-speaker-audio-review-jpg.52897/',
    'Measurement Date': pd.Timestamp('2020-03-05'),
    'Active': False,
    'Price (Single, USD)': 450.00,
  }, {
    'Speaker': 'Revel M22',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-m22-spinorama-zip.56078/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/revel-m22-speaker-review.12279/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/revel-m22-standmount-speaker-review-jpg.56066/',
    'Measurement Date': pd.Timestamp('2020-03-28'),
    'Active': False,
    'Price (Single, USD)': 300.00,  # used
  }, {
    'Speaker': 'Selah Audio RC3R',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/selah-audio-rc3r-spinorama-zip.48264/',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/selah-audio-rc3r-3-way-speaker-review.11218/',
    'Product URL': 'http://www.selahaudio.com/monitors',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/selah-audio-rc3r-3-way-speaker-review-jpg.48249/',
    'Measurement Date': pd.Timestamp('2020-02-01'),
    'Active': False,
    'Price (Single, USD)': 650.00,
  }, {
    'Speaker': 'Tannoy System 600',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/tannoy-system-600-spinorama-zip.53279/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/tannoy-system-600-speaker-review.11919/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/tannoy-system-600-speaker-review-jpg.53268/',
    'Measurement Date': pd.Timestamp('2020-03-08'),
    'Active': False,
    'Price (Single, USD)': 250.00,  # wild guess
  }, {
    'Speaker': 'Verdant Audio Bambusa MG 1',
    'Enabled': True,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/bambusa-mg-1-spinorama-zip.57040/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/verdant-audio-bambusa-mg-1-speaker-review.12385/',
    'Product URL': 'https://verdantaudio.com/products/bambusa-mg-1-pair',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/bambusa-mg-1-bookshelf-speaker-audio-review-jpg.57041/',
    'Measurement Date': pd.Timestamp('2020-04-03'),
    'Active': False,
    'Price (Single, USD)': 2500.00,
  }, {
    'Speaker': 'Zaph Audio ZA5.2 TM (built by Winkleswizard)',
    'Enabled': False,
    'Data URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/zaph-audio-za5-zip.54633/',
    'Data License': 'Creative Commons BY-NC-SA 4.0',
    'Review URL': 'https://www.audiosciencereview.com/forum/index.php?threads/zaph-audio-za5-diy-kit-speaker-review.12086/',
    'Product URL': 'https://www.audiosciencereview.com/forum/index.php?threads/zaph-audio-za5-2-tm-build-progress.11426/',
    'Picture URL': 'https://www.audiosciencereview.com/forum/index.php?attachments/zaph-audio-za5-diy-speaker-kit-audio-review-jpg.54611/',
    'Measurement Date': pd.Timestamp('2020-03-16'),
    'Active': False,
    'Price (Single, USD)': 170.00,
  },
]).set_index('Speaker')

def speaker_checkbox(speaker):
    speaker = speaker.copy()
    def speaker_change(new):
        speakers.loc[speaker.name, 'Enabled'] = new
    return setting(
        Path('speakers') / 'enabled' / speaker.name,
        widgets.Checkbox(value=speaker.loc['Enabled'], description=speaker.name, style={'description_width': 'initial'}),
        speaker_change)
    return checkbox

form(widgets.VBox(list(speakers.apply(speaker_checkbox, axis='columns'))))
```

```python
speakers.loc[:, ['Enabled', 'Active', 'Price (Single, USD)', 'Measurement Date']]
```

```python
def speaker_list_html():
    doc, tag, text, line = yattag.Doc().ttl()
    for speaker_name in speakers.index:
        speaker = speakers.loc[speaker_name, :]
        with tag('h2', style='clear: left; padding-top: 20px'):
            text(speaker_name + (' (ENABLED)' if speaker['Enabled'] else ''))
        doc.stag('img', src=speaker['Picture URL'], width=200, style='float: left; margin-right: 20px')
        product_url = speaker['Product URL']
        if not pd.isna(product_url):
            line('a', 'Product page', href=speaker['Product URL'], target='_blank')
            text(' - ')
        line('a', 'Review', href=speaker['Review URL'], target='_blank')
        text(' - ')
        line('a', 'Data package', href=speaker['Data URL'], target='_blank')
        doc.stag('br')
        with tag('b'): text('Active' if speaker['Active'] else 'Passive')
        doc.stag('br')
        with tag('b'): text('Price: ')
        text('${:.0f} (single)'.format(speaker['Price (Single, USD)']))
    return doc.getvalue()

IPython.display.HTML(speaker_list_html())
```

# Data intake

## Download and unpack

This downloads and unpacks speaker measurement data for each *enabled* speaker using the URL specified in `data_url`. This step is skipped if the files already exist in the `speaker_data` folder.

```python
Path('speaker_data').mkdir(exist_ok=True)
for speaker_name, speaker_data_url in speakers.loc[speakers['Enabled'], 'Data URL'].items():
    if not (Path('speaker_data') / speaker_name).exists():
        if not (Path('speaker_data') / (speaker_name + '.zip')).exists():
            !wget -O "speaker_data/{speaker_name}.zip" "{speaker_data_url}"
        !unzip "speaker_data/{speaker_name}.zip" -d "speaker_data/{speaker_name}"
```

<!-- #region id="load" -->
## Load
<!-- #endregion -->

This loads all data from all speakers into a single, massive `speaker_fr_raw`
DataFrame. The DataFrame index is arranged by speaker name, then frequency. All
data files for each speaker are merged to form the columns of the DataFrame.

```python
# pd.read_table() expects the following multi-level column headers:
#   A, A, A, A, B, B, B, B
#   I, I, J, J, K, K, L, L
#   X, Y, X, Y, X, Y, X, Y
# But the data we have uses the following header format instead:
#   A, B
#   I, J, K, L
#   X, Y, X, Y, X, Y, X, Y
# When confronted with this header, pd.read_table() gets confused and generates
# the following multi-level column index:
#   A, _, _, _, B, _, _, _
#   I, _, J, _, K, _, L, _
#   X, Y, X, Y, X, Y, X, Y
# Where "_" is some autogenerated column name in the form: "Unnamed: 1_level_0"
# This function restores the correct column names by replacing every "Unnamed"
# column with the name of the last known column on that level.
def fix_unnamed_columns(columns):
    last_names = [None] * columns.nlevels
    def fix_column(column):
        for level, label in enumerate(column):
            if not label.startswith('Unnamed: '):
                last_names[level] = label
        return tuple(last_names)
    return pd.MultiIndex.from_tuples(fix_column(column) for column in columns.values)

# Expects input in the following form:
#   (Additional top column levels)
#   FR1                     FR2
#   "Frequency [Hz]" value  "Frequency [Hz]" value
#   42.42            1.234  42.42            2.345
#   43.43            3.456  43.43            5.678
# And reindexes it by the "Frequency [Hz]" column, producing:
#          value
#          (Additional top column labels)
#          FR1    FR2
#   42.42  1.234  2.345
#   43.43  3.456  5.678
def index_by_frequency(data):
    preserve_column_level = list(range(data.columns.nlevels - 1))
    return (data
      # Move all columns levels except the bottommost one into the index
      .stack(level=preserve_column_level)
      # Drop the topmost (default) index level as it's not useful anymore
      .reset_index(level=0, drop=True)
      # Use the frequency as the new bottommost index level
      .set_index('Frequency [Hz]', append=True)
      # Move all other index levels back to columns
      .unstack(level=preserve_column_level))

# In "Sound Pessure Level [dB] / [2.83V 1m]", eliminates " / [2.83V 1m]", as it varies between measurements
def cleanup_spl_column(column):
    match = re.match(r'^(Sound Pessure Level \[dB\])', column)
    return column if match is None else match.group(1)

def load_fr(file):
    fr = pd.read_table(file, header=[0, 1, 2], thousands=',')
    fr.columns = fix_unnamed_columns(fr.columns)
    return (fr
      .rename(columns=cleanup_spl_column)
      .pipe(index_by_frequency))

# If the none_missing() assertion fires, it likely means something is wrong or
# corrupted in the data files of the speaker (e.g. some frequencies present in
# some columns/files but not others)
@ed.none_missing()
def load_speaker(dir):
    return pd.concat(
        (load_fr(file) for file in filter(lambda path: not path.name in ('LICENSE.txt', 'Read License Agreement.txt'), dir.iterdir())),
        axis='columns')

speakers_fr_raw = pd.concat(
  {speaker.Index: load_speaker(Path('speaker_data') / speaker.Index) for speaker in speakers[speakers['Enabled']].itertuples()},
  names=['Speaker'], axis='rows')
speakers_fr_raw
```

<!-- #region id="raw-summary" -->

# Raw data summary

Basic information about loaded data, including frequency bounds and resolution.

<!-- #endregion -->

```python
speakers_frequencies = (speakers_fr_raw
  .index
  .to_frame()
  .reset_index(drop=True)
  .groupby('Speaker'))
speakers_frequency_count = speakers_frequencies.count().loc[:, 'Frequency [Hz]'].rename('Frequencies')
speakers_min_frequency = speakers_frequencies.min().loc[:, 'Frequency [Hz]'].rename('Min Frequency (Hz)')
speakers_max_frequency = speakers_frequencies.max().loc[:, 'Frequency [Hz]'].rename('Max Frequency (Hz)')
speakers_octaves = (speakers_max_frequency / speakers_min_frequency).apply(np.log2).rename('Extent (octaves)')
speakers_freqs_per_octave = (speakers_frequency_count / speakers_octaves).rename('Mean resolution (freqs/octave)')
pd.concat([
  speakers_frequency_count,
  speakers_min_frequency,
  speakers_max_frequency,
  speakers_octaves,
  speakers_freqs_per_octave
], axis='columns')
```

```python
# Similar to joining `df` against `labels`, but columns from `labels` are added as index levels to `df`, instead of columns.
# Particularly useful when touching columns risks wreaking havoc in a multi-level column index.
#
# For example, given `df`:
#   C0
# A
# i  1 
#    2
# j  3
#    4
#
# And `labels`:
#   C1 C2
# A
# i 1i 2i
# j 1j 2j
#
# Then the result will be:
#         C0
# A C1 C2
# i 1i 2i  1
#          2
# j 1j 2j  3
#          4
def join_index(df, labels):
    return df.align(labels.set_index(list(labels.columns.values), append=True), axis='index')[0]

speakers_fr_annotated = (speakers_fr_raw
    .unstack(level='Frequency [Hz]')
    .pipe(join_index, speakers_freqs_per_octave.to_frame())
    .stack()
)
```

<!-- #region id="sensitivity" -->

# Sensitivity

This calculates a single sensitivity value for each speaker using the **mean on-axis SPL** in a configurable frequency band. The result can then be used as the basis for normalization (see next section).

<!-- #endregion -->

The recommended frequency band is **200-400 Hz**, as it appears to be the most appropriate for normalization - c.f. [Olive](http://www.aes.org/e-lib/online/browse.cfm?elib=12847) (section 3.2.1):

> The use of a reference band of 200-400 Hz is based
> on an observation made in Part One (see section 4.8
> of Part 1). When asked to judge the spectral balance of
> each loudspeaker across 6 frequency bands, listeners
> referenced or anchored their judgments to the band
> centered around 200 Hz. One plausible explanation is
> that many of the fundamentals of instruments,
> including voice, fall within 200-400 Hz, and the
> levels of the higher harmonics are referenced to it.

Note that in other contexts a band centered around 1 kHz is often used.

**CAUTION:** take the numbers in the below table with a grain of salt. Indeed the raw measurement data is using the wrong absolute scale for some speakers, especially active ones.

```python
def frequency_slider(**kwargs):
    return widgets.FloatLogSlider(base=10, min=np.log10(20), max=np.log10(20000), step=0.1, readout_format='.2s', layout=widgets.Layout(width='90%'), **kwargs)

sensitivity_first_frequency_hz = setting(
    'sensitivity/first_frequency_hz',
    frequency_slider(value=200, description='First frequency (Hz)', style={'description_width': 'initial'}))
sensitivity_last_frequency_hz = setting(
    'sensitivity/last_frequency_hz',
    frequency_slider(value=400, description='Last frequency (Hz)', style={'description_width': 'initial'}))

form(widgets.VBox([sensitivity_first_frequency_hz, sensitivity_last_frequency_hz]))
```

```python
sensitivity_input_column = ('Sound Pessure Level [dB]', 'CEA2034', 'On Axis')
speakers_sensitivity = (speakers_fr_raw
  .loc[speakers_fr_raw.index.to_frame()['Frequency [Hz]'].between(sensitivity_first_frequency_hz.value, sensitivity_last_frequency_hz.value), sensitivity_input_column]
  .mean(level='Speaker'))
speakers_sensitivity.to_frame()
```

<!-- #region id="normalization" -->

# Normalization & detrending

This step normalizes *all* SPL frequency response data (on-axis, spinorama, off-axis, estimated in-room response, etc.).

<!-- #endregion -->

The data is normalized according to the `normalization_mode` variable, which can take the following values:

 - **None**: raw absolute SPL values are carried over as-is.
 - **Equal sensitivity** (recommended): sensitivity values calculated in the previous section are subtracted from all SPL values of each speaker, such that all speakers have 0 dB sensitivity. Improves readability and makes it easier to compare speakers.
 - **Flat on-axis**: the on-axis SPL value is subtracted to itself as well as every other SPL variable at each frequency. In other words this simulates EQ'ing every speaker to be perfectly flat on-axis. Use this mode to focus solely on directivity data.
 - **Flat listening window**: same as above, using the Listening Window average instead of On-Axis.
 - **Detrend**: for each speaker, computes a smoothed response (using the same mechanism as described in the *Smoothing* section below), then subtracts it from the original responses. In other words, this is the opposite of smoothing. Useful for removing trends (e.g. overall bass/treble balance) to focus solely on local variations.
 
## Detrending settings
 
If **Detrend each response individually** is checked, individual responses are smoothed and subtracted independently of each other, *including* directivity indices. Otherwise, a smoothed version of the **Detrending reference** will be subtracted to all responses for that speaker, *excluding* directivity indices.

The **Detrending strength** is the strength of the smoothing applied to the subtracted response.

```python
detrend_reference = setting(
    'normalization/detrend_reference',
    widgets.RadioButtons(
        description='Detrending reference',
        options=['On Axis', 'Listening Window', 'Early Reflections', 'Sound Power'], value='On Axis',
        style={'description_width': 'initial'},
        layout={'width': 'max-content'}))
detrend_individually = setting(
    'normalization/detrend_individually',
    widgets.Checkbox(
        description='Detrend each response individually',
        value=False,
        style={'description_width': 'initial'}),
    on_new_value=lambda value: display_widget(detrend_reference, not value))
detrend_octaves = setting(
    'normalization/detrend_octaves',
    widgets.SelectionSlider(
        description='Detrending strength',
        options=[
            ('2/1-octave', 2/1),
            ('1/1-octave', 1/1),
            ('1/2-octave', 1/2),
            ('1/3-octave', 1/3),
            ('1/6-octave', 1/6),
        ], value=1/1,
        style={'description_width': 'initial'}))
detrend = widgets.VBox([detrend_individually, detrend_reference, detrend_octaves])

normalization_mode = setting(
    'normalization/mode',
    widgets.RadioButtons(
        description='Normalization mode',
        options=[
            ('None', 'none'),
            ('Equal sensitivity', 'sensitivity'),
            ('Flat on-axis', 'on_axis'),
            ('Flat listening window', 'listening_window'),
            ('Detrend', 'detrend'),
        ], value='sensitivity',
        style={'description_width': 'initial'}),
    on_new_value=lambda value: display_widget(detrend, value == 'detrend'))

form(widgets.HBox([normalization_mode, detrend]))
```

```python
def smooth(speaker_fr, octaves):
    (freqs_per_octave,) = speaker_fr.index.to_frame().loc[:, 'Mean resolution (freqs/octave)'].unique()
    return (speaker_fr
        # Ensure the input to ewm() is sorted by frequency, otherwise things will get weird fast. This should already be the case, but make sure regardless.
        .sort_index()
        # Note that this assumes points are equally spaced in log-frequency.
        .ewm(span=freqs_per_octave*octaves).mean()
    )

speakers_fr_splnorm = speakers_fr_annotated.loc[:, 'Sound Pessure Level [dB]']
speakers_fr_dinorm = speakers_fr_annotated.loc[:, '[dB] Directivity Index ']
spl_axis_label = ['Absolute Sound Pressure Level (dB SPL)']
di_axis_label = ['Directivity Index (dBr)']
spl_domain = (55, 105)
di_domain = (-5, 10)
if normalization_mode.value == 'sensitivity':
    speakers_fr_splnorm = speakers_fr_splnorm.sub(
        speakers_sensitivity, axis='index', level='Speaker')
    spl_axis_label = ['Relative Sound Pressure (dBr)']
    spl_domain = (-40, 10)
if normalization_mode.value == 'on_axis':
    speakers_fr_splnorm = speakers_fr_splnorm.sub(
        speakers_fr_raw.loc[:, ('Sound Pessure Level [dB]', 'CEA2034', 'On Axis')], axis='index')
    spl_axis_label = ['Sound Pressure (dBr)', 'relative to on-axis']
    spl_domain = (-40, 10)
if normalization_mode.value == 'listening_window':
    speakers_fr_splnorm = speakers_fr_splnorm.sub(
        speakers_fr_raw.loc[:, ('Sound Pessure Level [dB]', 'CEA2034', 'Listening Window')], axis='index')
    spl_axis_label = ['Sound Pressure (dBr)', 'relative to listening window']
    spl_domain = (-40, 10)
if normalization_mode.value == 'detrend':
    detrend_octaves_label = lookup_widget_option_label(detrend_octaves)
    if detrend_individually.value:
        speakers_fr_splnorm = speakers_fr_splnorm.sub(speakers_fr_splnorm
            .groupby('Speaker')
            .apply(smooth, detrend_octaves.value))
        spl_axis_label = ['Sound Pressure (dBr)', detrend_octaves_label + ' detrended']
        spl_domain = (-25, 25)
        speakers_fr_dinorm = speakers_fr_dinorm.sub(speakers_fr_dinorm
            .groupby('Speaker')
            .apply(smooth, detrend_octaves.value))
        di_axis_label = ['Directivity Index (dBr)', detrend_octaves_label + ' detrended']
        di_domain = (-7.5, 7.5)
    else:
        speakers_fr_splnorm = speakers_fr_splnorm.sub(speakers_fr_splnorm.loc[:, ('CEA2034', detrend_reference.value)]
            .groupby('Speaker')                     
            .apply(smooth, detrend_octaves.value), axis='index')
        spl_axis_label = ['Sound Pressure (dBr)', 'relative to {} smoothed {} (dBr)'.format(detrend_octaves_label, detrend_reference.value)]
        spl_domain = (-40, 10)
        
speakers_fr_norm = pd.concat([speakers_fr_splnorm, speakers_fr_dinorm], axis='columns')
speakers_fr_norm
```

<!-- #region id="smoothing" -->

# Smoothing

All responses (including directivity indices) are smoothed according to the settings below.

<!-- #endregion -->

Smoothing is done by applying an [exponential moving average (EMA)](https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average) with a "span" or "N" corresponding to the number of octaves chosen (since points in the input are already equally spaced in log-frequency). EMA was chosen over a simple moving average because it gracefully handles the case where N is not an integer, as is often the case here.

Note that the current algorithm makes the implicit assumption that the input data is equally log-spaced in frequency (see "Data Check", "Resolution" below). With recent datasets this assumption tends to break down below ~100 Hz, where points are further apart than expected, leading to excessive smoothing.

```python
smoothing_octaves = setting(
    'smoothing/octaves',
    widgets.SelectionSlider(
        description='Smoothing strength',
        options=[
            ('1/1-octave', 1/1),
            ('1/2-octave', 1/2),
            ('1/3-octave', 1/3),
            ('1/6-octave', 1/6),
            ('1/12-octave', 1/12),
        ], value=1/1,
        style={'description_width': 'initial'}))
smoothing_preserve_original = setting(
    'smoothing/preserve_original',
    widgets.RadioButtons(
        options=[
            ('Display smoothed data alongside unsmoothed data', True),
            ('Drop unsmoothed data', False),
        ], value=True,
        layout={'width': 'max-content'}))
smoothing_params = widgets.VBox([smoothing_octaves, smoothing_preserve_original])
smoothing_enabled = setting(
    'smoothing/enabled',
    widgets.Checkbox(
        description='Enable smoothing',
        value=False,
        style={'description_width': 'initial'}),
    on_new_value=lambda value: display_widget(smoothing_params, value))

form(widgets.HBox([smoothing_enabled, smoothing_params]))
```

```python
# Appends a new index level with all identical values.
def append_constant_index(df, value, name=None):
    return df.set_index(pd.Index([value] * df.shape[0], name=name), append=True)

speakers_fr_smoothed = (speakers_fr_norm
    .unstack(level='Frequency [Hz]')
    .pipe(append_constant_index, 'No smoothing', name='Smoothing')
    .stack()
)
if smoothing_enabled.value:
    speakers_fr_smoothed_only = (speakers_fr_norm
        .groupby('Speaker')
        .apply(smooth, smoothing_octaves.value)
        .unstack(level='Frequency [Hz]')
        .pipe(append_constant_index,
              lookup_widget_option_label(smoothing_octaves) + ' smoothing',
              name='Smoothing')
        .stack())
    speakers_fr_smoothed = (
        pd.concat([speakers_fr_smoothed, speakers_fr_smoothed_only])
        if smoothing_preserve_original.value else speakers_fr_smoothed_only)
speakers_fr_smoothed
```

<!-- #region id="plot-settings" -->

# Plot settings

Here you can customize some parameters related to the charts.

<!-- #endregion -->

```python
# @markdown In standalone charts, offset speaker traces by this many dB. (`-10` is a good starting point.)
speaker_offset_db = 0  # @param {type:"number"}
# @markdown Dimensions for standalone charts
standalone_chart_width = 800  # @param {type:"integer"}
standalone_chart_height = 400  # @param {type:"integer"}
# @markdown Dimensions for side-by-side charts
sidebyside_chart_width = 600  # @param {type:"integer"}
sidebyside_chart_height = 300  # @param {type:"integer"}

# Removes index levels from `df` that have identical values throughout.
# Also returns a Series with the index levels that were removed, along with their common value.
#
# For example, given:
#          COL
#  A  B  C
# a1  b  c   1
# a2  b  c   2
# a2  b  c   3
#
# Will return:
#    COL
#  A
# a1   1
# a2   2
# a2   3
#
# And:
# B b
# C c
def extract_common_index_levels(df):
    index_df = (df
        .index
        .to_frame()
        .reset_index(drop=True)
    )
    index_has_distinct_values = index_df.nunique() > 1
    index_common_names = index_has_distinct_values.loc[~index_has_distinct_values].index
    def extract_unique_index_value(index_name):
        (unique_index_value,) = index_df.loc[:, index_name].unique()
        return unique_index_value
    common_info = (index_common_names
        .to_series()
        .apply(extract_unique_index_value)
    )
    df = df.copy()
    df.index = pd.MultiIndex.from_frame(
        index_df.drop(columns=index_common_names))
    return df, common_info

# Rearranges the index, folding metadata such as resolution and smoothing into the "Speaker" index level.
def fold_speakers_info(speakers_fr):
    speakers_fr = (speakers_fr
        .unstack(level='Frequency [Hz]')
        .copy()
    )
    speakers_fr.index = pd.MultiIndex.from_frame(speakers_fr
        .index
        .to_frame()
        .apply(
            # Ideally this should be on multiple lines, but it's not clear if that's feasible: https://github.com/vega/vega-lite/issues/5994
            lambda speaker: pd.Series({'Speaker': '; '.join(speaker)}),
            axis='columns')
    )
    return speakers_fr.stack()

(speakers_fr_ready, common_title) = (speakers_fr_smoothed
    .rename(
        level='Mean resolution (freqs/octave)',
        index=lambda freqs_per_octave: 'Mean {:.2g} pts/octave'.format(freqs_per_octave))
    .rename_axis(index={'Mean resolution (freqs/octave)': 'Resolution'})
    .pipe(extract_common_index_levels)
)
single_speaker_mode = speakers_fr_ready.index.names == ['Frequency [Hz]']
if single_speaker_mode:
    # Re-add an empty Speaker index level.
    # The alternative would be to handle this case specially in every single graph, which gets annoying fast.
    speakers_fr_ready = (speakers_fr_ready
        .pipe(append_constant_index, '', name='Speaker')
        .swaplevel(0, -1)
    )
else:
    speakers_fr_ready = fold_speakers_info(speakers_fr_ready)
common_title = alt.TitleParams(
    text='; '.join(common_title.to_list()),
    anchor='start')

speaker_offsets = speakers_fr_ready.index.get_level_values('Speaker').drop_duplicates().to_frame().reset_index(drop=True).reset_index().set_index('Speaker').loc[:, 'index']*speaker_offset_db
def relabel_speaker_with_offset(speaker_name):
    speaker_offset = speaker_offsets.loc[speaker_name]
    return speaker_name + ('' if speaker_offset == 0 else ' [{:+.0f} dB]'.format(speaker_offsets.loc[speaker_name]))
speakers_fr_ready_offset = (speakers_fr_ready
    # Arguably it would cleaner to use some kind of "Y offset" encoding channel in charts, but that doesn't seem to be supported yet: https://github.com/vega/vega-lite/issues/4703
    .add(speaker_offsets, axis='index', level='Speaker')
    .rename(relabel_speaker_with_offset, level='Speaker')
)

speakers_license = speakers.loc[
    speakers_fr_smoothed.index.get_level_values('Speaker').drop_duplicates(),
    'Data License']
credits = ['Data: amirm, AudioScienceReview.com - Plotted by Loudspeaker Explorer']
if speakers_license.nunique(dropna=False) == 1:
    (unique_license,) = speakers_license.unique()
    if (pd.notna(unique_license)):
        credits.append('Data licensed under {}'.format(unique_license))
else:
    for speaker, license in speakers_license.dropna().items():
        credits.append('{} data licensed under {}'.format(speaker, license))

alt.data_transformers.disable_max_rows()

# Prepares DataFrame `df` for charting using alt.Chart().
#
# Altair doesn't use the index, so we move it into columns. Then columns are
# renamed according to the `columns_mapper` dict. (This is necessary because
# Altair doesn't work well with verbose column names, and it doesn't support
# multi-level columns anyway.) Columns that don't appear in the dict are
# dropped.
#
# Note: contrary to DataFrame.rename(), in the case of MultiIndex columns,
# `columns_mapper` keys are matched against the full column name (i.e. a tuple),
# not individual per-level labels.
def prepare_alt_chart(df, columns_mapper):
    df = df.reset_index().loc[:, list(columns_mapper.keys())]
    df.columns = df.columns.map(mapper=columns_mapper)
    return df

def set_chart_dimensions(chart, sidebyside=False):
    if single_speaker_mode:
        sidebyside = False
    return chart.properties(
        width=sidebyside_chart_width if sidebyside else standalone_chart_width,
        height=sidebyside_chart_height if sidebyside else standalone_chart_height)

def frequency_tooltip():
    return alt.Tooltip('frequency', title='Frequency (Hz)', format='.03s')

def frequency_response_chart(data, sidebyside=False, additional_tooltips=[]):
    return alt.pipe(
        alt.Chart(data, title=common_title),
        lambda chart:
            set_chart_dimensions(chart, sidebyside)
            .encode(
              frequency_xaxis('frequency'),
              tooltip=additional_tooltips + [
                  frequency_tooltip(),
                  alt.Tooltip('value', title='Value (dB)', format='.2f')]))

def interactive_line(chart, legend_channel_fn):
    mouseover_selection = alt.selection_single(on='mouseover', empty='none')
    legend_selection = alt.selection_multi(encodings=['color'], bind='legend')
    # This is equivalent to using the `point` line mark property.
    # The reason why we don't simply do that is because tooltips wouldn't work as well due to this Vega-lite bug: https://github.com/vega/vega-lite/issues/6107
    return alt.layer(
        # Note: order is important. If the points chart comes first, legend selection doesn't work.
        chart
            .mark_line(clip=True, interpolate='monotone')
            .add_selection(legend_selection)
            .encode(
                legend_channel_fn(True),
                opacity=alt.condition(legend_selection, alt.value(1), alt.value(0.2))
            ),
        chart
            .mark_circle(clip=True, size=100)
            .add_selection(mouseover_selection)
            .encode(
                # Disable the legends for points to ensure the legend uses the line shape and a continuous scale if applicable.
                # We don't use legend_selection for points. If we do, it seems to break legend interactivity in weird ways on non-faceted charts.
                legend_channel_fn(False),
                fillOpacity=alt.condition(mouseover_selection, alt.value(0.3), alt.value(0)))
            .interactive())

def frequency_xaxis(shorthand):
    return alt.X(shorthand, title='Frequency (Hz)', scale=alt.Scale(type='log', base=10, nice=False), axis=alt.Axis(format='s'))

def sound_pressure_yaxis(title_prefix=None):
    return alt.Y('value', title=[(title_prefix + ' ' if title_prefix else '') + spl_axis_label[0]] + spl_axis_label[1:], scale=alt.Scale(domain=spl_domain), axis=alt.Axis(grid=True))

def directivity_index_yaxis(title_prefix=None, scale_domain=di_domain):
    return alt.Y('value', title=[(title_prefix + ' ' if title_prefix else '') + di_axis_label[0]] + di_axis_label[1:], scale=alt.Scale(domain=scale_domain), axis=alt.Axis(grid=True))

def variable_color_fn(**kwargs):
    return lambda show_legend: alt.Color(
        'variable', title=None, sort=None,
        legend=alt.Legend() if show_legend else None,
        **kwargs)
 
def speaker_color_fn(**kwargs):
    return lambda show_legend: alt.Color('speaker',
        title=None,
        legend=alt.Legend(orient='top', direction='vertical', labelLimit=600) if show_legend and not single_speaker_mode else None,
        **kwargs)

def speaker_facet(chart):
    return chart.facet(
        alt.Column('speaker', title=None),
        title=common_title)

def speaker_input(chart):
    speakers = list(speakers_fr_ready.index.get_level_values('Speaker').drop_duplicates().values)
    if len(speakers) < 2: return chart
    selection = alt.selection_single(
            fields=['speaker'],
            bind=alt.binding_select(
                name='Speaker: ', options=[None] + speakers, labels=['All'] + speakers))
    return chart.transform_filter(selection).add_selection(selection)

# Given a DataFrame with some of the columns in the following format:
#   'On-Axis' '10°' '20°' '-10°' ...
# Converts the above column labels to the following:
#   0.0 10.0 20.0 -10.0
def convert_angles(df):
    def convert_label(label):
        if label == 'On-Axis':
            return 0.0
        stripped_label = label.strip('°')
        if stripped_label == label:
            return label
        try:
            return float(stripped_label)
        except ValueError:
            return label
    return df.rename(columns=convert_label)

def postprocess_chart(chart):
    # Altair/Vega-Lite doesn't provide a way to set multiple titles or just display arbitrary text.
    # We hack around that limitation by concatenating with a dummy chart that has a title.
    # See https://github.com/vega/vega-lite/issues/5997
    return (alt.vconcat(
        chart,
        alt.Chart(title=alt.TitleParams(
            credits, fontSize=10, fontWeight='lighter', color='gray', anchor='start')).mark_text())
        .resolve_legend(color='independent')
        .configure_view(width=600, height=1, opacity=0))
```

<!-- #region id="data-check" -->

# Data check

The charts in these section can be used to sanity check the input data. They are not particularly useful unless you suspect a problem with the data.

<!-- #endregion -->

## Resolution

This chart shows the resolution of the input data at each frequency. For each point, resolution is calculated by looking at the distance from the previous point. The larger the distance, the lower the resolution.

A straight, horizontal line means that resolution is constant throughout the spectrum, or in other words, points are equally spaced in log-frequency. Some Loudspeaker Explorer features, especially smoothing and detrending, implicitly assume that this is the case, and might produce inaccurate results otherwise.

```python
alt.pipe(
    speakers_fr_ready
        .index.to_frame()
        .reset_index(drop=True)
        .set_index('Speaker')
        .set_index('Frequency [Hz]', append=True, drop=False)
        .groupby('Speaker').apply(lambda frequencies: frequencies / frequencies.shift(1))
        .pipe(np.log2)
        .pow(-1)
        .rename(columns={'Frequency [Hz]': 'Resolution (points/octave)'})
        .pipe(prepare_alt_chart, {
            'Speaker': 'speaker',
            'Frequency [Hz]': 'frequency',
            'Resolution (points/octave)': 'value',
        }),
    lambda data: alt.Chart(data, title=common_title),
    lambda chart:
        set_chart_dimensions(chart)
        .encode(
            frequency_xaxis('frequency'),
            alt.Y('value', title='Resolution (points/octave)', axis=alt.Axis(grid=True)),
            tooltip=[
                alt.Tooltip('speaker', title='Speaker'),
                frequency_tooltip(),
                alt.Tooltip('value', title='Resolution (points/octave)', format='.2f')]),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    postprocess_chart)
```

# Standard measurements

Note that all the data shown in this section is a direct representation of the input data after normalization. No complex processing is done. In particular, data for derived metrics such as *Listening Window*, *Early Reflections*, *Sound Power*, Directivity Indices and even *Estimated In-Room Response* come directly from the input - they are not derived by this code.


## Spinorama

The famous CEA/CTA-2034 charts, popularized by Dr. Floyd Toole. These provide a good summary of the measurements from a perceptual perspective. Speakers are presented side-by-side for easy comparison.

Remember:
 - **All the charts are interactive.** Use the mousewheel to zoom, and drag & drop to pan. Click on a legend entry to highlight a single response; hold shift to highlight multiple responses. Double-click to reset the view. (PROTIP: to quickly switch back and forth between speakers, select the speaker dropdown, then use the left-right arrow keys on your keyboard.)
 - **Charts will not be generated if the section they're under is folded while the notebook is running.** To manually load a chart after running the notebook, click on the square to the left of the *Show Code* button. Or simply use *Run all* again after unfolding the section.

```python
spinorama_chart_legend_selection = alt.selection_multi(fields=['variable'], bind='legend')
spinorama_chart_common = alt.pipe(
    speakers_fr_ready
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('CEA2034', 'On Axis'): 'On Axis',
          ('CEA2034', 'Listening Window'): 'Listening Window',
          ('CEA2034', 'Early Reflections'): 'Early Reflections',
          ('CEA2034', 'Sound Power'): 'Sound Power',
          ('Directivity Index', 'Early Reflections DI'): 'Early Reflections DI',
          ('Directivity Index', 'Sound Power DI'): 'Sound Power DI',
        }).melt(['speaker', 'frequency']),
    lambda data: frequency_response_chart(data,
        sidebyside=True,
        additional_tooltips=[alt.Tooltip('variable', title='Response')]))

# Note that there are few subtleties here because of Altair/Vega quirks:
# - To make the Y axes independent, `.resolve_scale()` has to be used *before
#   and after* `.facet()`. (In Vega terms, there needs to be a Resolve property
#   in *every* view composition specification.)
#   - If the first `.resolve_scale()` is removed from the layer spec, the axes
#     are not made independent.
#   - If the second `.resolve_scale()` is removed from the facet spec, Vega
#     throws a weird `Unrecognized scale name: "child_layer_0_y"` error.
# - To make the two axes zoom and pan at the same time, `.interactive()` has to
#   be used on each encoding, not on the overall view. Otherwise only the left
#   axis will support zoom & pan.
alt.pipe(
    alt.layer(
        alt.pipe(
            spinorama_chart_common
                .encode(sound_pressure_yaxis())
                .transform_filter(alt.FieldOneOfPredicate(field='variable', oneOf=['On Axis', 'Listening Window', 'Early Reflections', 'Sound Power'])),
            lambda chart: interactive_line(chart, variable_color_fn())),
        alt.pipe(
            spinorama_chart_common
                .encode(directivity_index_yaxis(scale_domain=(-10, 40)))
                .transform_filter(alt.FieldOneOfPredicate(field='variable', oneOf=['Early Reflections DI', 'Sound Power DI'])),
            lambda chart: interactive_line(chart, variable_color_fn())))
        .resolve_scale(y='independent'),
    speaker_facet, speaker_input,
    lambda chart: chart.resolve_scale(y='independent'),
    postprocess_chart)
```

## On-axis response

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
            ('Speaker', ''): 'speaker',
            ('Frequency [Hz]', ''): 'frequency',
            ('CEA2034', 'On Axis'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(sound_pressure_yaxis(title_prefix='On Axis')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

<!-- #region id="off-axis-responses" -->

## Off-axis responses

Note that this chart can be particularly taxing on your browser due to the sheer number of points.

<!-- #endregion -->

Use the slider at the bottom to focus on a specific angle. Note that the slider can be slow to respond, especially if there are many speakers. Double-click the chart to reset.

Keep in mind that these graphs can be shown normalized to flat on-axis by changing the settings in the *Normalization* section above.

```python
def off_axis_angles_chart(direction):
    off_axis_angle_selection = alt.selection_single(
        fields=['angle'],
        bind=alt.binding_range(min=-170, max=180, step=10, name=direction + ' angle selector (°)'),
        clear='dblclick')
    return alt.pipe(
        speakers_fr_ready
            .loc[:, 'SPL ' + direction]
            .pipe(convert_angles)
            .rename_axis(columns='Angle')
            .stack()
            .reset_index()
            .pipe(prepare_alt_chart, {
                'Speaker': 'speaker',
                'Angle': 'angle',
                'Frequency [Hz]': 'frequency',
                0: 'value',
              }),
        lambda data: frequency_response_chart(data,
            sidebyside=True,
            additional_tooltips=[alt.Tooltip('angle', title=direction + ' angle (°)')])
            .transform_filter(off_axis_angle_selection)
            .encode(sound_pressure_yaxis()),
        lambda chart: interactive_line(
            chart, legend_channel_fn=lambda show_legend: alt.Color(
                'angle', title=direction + ' angle (°)',
                scale=alt.Scale(scheme='sinebow', domain=(-180, 180)),
                legend=alt.Legend(gradientLength=300, values=list(range(-180, 180+10, 10))) if show_legend else None))
            .add_selection(off_axis_angle_selection),
        speaker_facet, speaker_input,
        postprocess_chart)

off_axis_angles_chart('Horizontal')
```

```python
off_axis_angles_chart('Vertical')
```

<!-- #region id="horizontal-reflection-responses" -->

## Horizontal reflection responses

<!-- #endregion -->

```python
alt.pipe(
    speakers_fr_ready
        .loc[:, 'Horizontal Reflections']
        .rename_axis(columns=['Direction'])
        .rename(columns=lambda column: re.sub(' ?Horizontal ?', '', re.sub(' ?Reflection ?', '', column)))
        .stack(level=['Direction'])
        .reset_index()
        .pipe(prepare_alt_chart, {
            'Speaker': 'speaker',
            'Direction': 'variable',
            'Frequency [Hz]': 'frequency',
            0: 'value',
        }),
    lambda data: frequency_response_chart(data,
        sidebyside=True,
        additional_tooltips=[alt.Tooltip('variable', title='Direction')])
        .encode(sound_pressure_yaxis()),
    lambda chart: interactive_line(chart, variable_color_fn()),
    speaker_facet, speaker_input,
    postprocess_chart)
```

<!-- #region id="vertical-reflection-responses" -->

## Vertical reflection responses

<!-- #endregion -->

```python
alt.pipe(
    speakers_fr_ready
        .loc[:, 'Vertical Reflections']
        .rename_axis(columns=['Direction'])
        .rename(columns=lambda column: re.sub(' ?Vertical ?', '', re.sub(' ?Reflection ?', '', column)))
        .stack(level=['Direction'])
        .reset_index()
        .pipe(prepare_alt_chart, {
            'Speaker': 'speaker',
            'Direction': 'variable',
            'Frequency [Hz]': 'frequency',
            0: 'value',
        }),
    lambda data: frequency_response_chart(data,
        sidebyside=True,
        additional_tooltips=[alt.Tooltip('variable', title='Direction')])
        .encode(sound_pressure_yaxis()),
    lambda chart: interactive_line(chart, variable_color_fn()),
    speaker_facet, speaker_input,
    postprocess_chart)
```

## Listening Window response

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('CEA2034', 'Listening Window'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(sound_pressure_yaxis(title_prefix='Listening Window')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

## Early Reflections response

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('CEA2034', 'Early Reflections'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(sound_pressure_yaxis(title_prefix='Early Reflections')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

## Sound Power response

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('CEA2034', 'Sound Power'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(sound_pressure_yaxis(title_prefix='Sound Power')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

## Early Reflections Directivity Index

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('Directivity Index', 'Early Reflections DI'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(directivity_index_yaxis(title_prefix='Early Reflections')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

## Sound Power Directivity Index

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('Directivity Index', 'Sound Power DI'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(directivity_index_yaxis(title_prefix='Sound Power')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

## Estimated In-Room Response

```python
alt.pipe(
    speakers_fr_ready_offset
        .pipe(prepare_alt_chart, {
          ('Speaker', ''): 'speaker',
          ('Frequency [Hz]', ''): 'frequency',
          ('Estimated In-Room Response', 'Estimated In-Room Response'): 'value',
        }),
    lambda data: frequency_response_chart(data,
        additional_tooltips=[alt.Tooltip('speaker', title='Speaker')])
        .encode(sound_pressure_yaxis(title_prefix='Estimated In-Room Response')),
    lambda chart: interactive_line(chart, speaker_color_fn()),
    speaker_input,
    postprocess_chart)
```

# Other measurements



## Listening Window detail

The Listening Window is defined by CTA-2034-A as the average of on-axis, ±10° vertical responses, and ±10º, ±20º and ±30º horizontal responses. Averages can be misleading as they can hide significant variation between angles.

This chart provides more detail by including each individual angle that is used in the Listening Window average. This can be used to assess the consistency of the response within the Listening Window.

```python
listening_window_detail_common = alt.pipe(
    speakers_fr_ready
        .pipe(prepare_alt_chart, {
            ('Speaker', ''): 'speaker',
            ('Frequency [Hz]', ''): 'frequency',
            ('CEA2034', 'Listening Window'): 'Listening Window',
            ('CEA2034', 'On Axis'): 'On Axis',
            ('SPL Vertical', '-10°'): '-10° Vertical',
            ('SPL Vertical',  '10°'): '+10° Vertical',
            ('SPL Horizontal', '-10°'): '-10° Horizontal',
            ('SPL Horizontal',  '10°'): '+10° Horizontal',
            ('SPL Horizontal', '-20°'): '-20° Horizontal',
            ('SPL Horizontal',  '20°'): '+20° Horizontal',
            ('SPL Horizontal', '-30°'): '-30° Horizontal',
            ('SPL Horizontal',  '30°'): '+30° Horizontal',
        })
        .melt(['speaker', 'frequency']),
    lambda data: frequency_response_chart(data,
        sidebyside=True,
        additional_tooltips=[alt.Tooltip('variable', title='Response')])
        .encode(sound_pressure_yaxis()))

listening_window_detail_highlight = alt.FieldOneOfPredicate(
    field='variable',
    oneOf=['Listening Window', 'On Axis'])

listening_window_color_fn = variable_color_fn(scale=alt.Scale(
    range=['#aeadd3', '#796db2', '#cec5c1', '#c0b8b4', '#b3aaa7', '#a59c99', '#98908c', '#8b827f', '#ff7f0e', '#2ca02c']))

alt.pipe(
    alt.layer(
        alt.pipe(
            listening_window_detail_common
                .transform_filter({'not': listening_window_detail_highlight})
                .encode(strokeWidth=alt.value(1.5)),
             lambda chart: interactive_line(chart, listening_window_color_fn)),
        alt.pipe(
            listening_window_detail_common
                .transform_filter(listening_window_detail_highlight),
            lambda chart: interactive_line(chart, listening_window_color_fn))),
    speaker_facet, speaker_input,
    postprocess_chart
)
```
